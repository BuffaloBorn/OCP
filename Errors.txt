GENERICS & COLLECTIONS
* Map<String, List<>> is wrong because of List<> being inside of another < and >. нельзя сдатавить diamond operator внутрь скобок
* Если метод возвращает List<? super E> то его нельзя кастонуть, только в List<? super E> или List<?> или List. public static <E extends CharSequence> List<? super E> doIt(List<E> nums)
* books.stream().sorted().forEach(b->System.out.println(b.getIsbn())); // упадет с ClassCastException если Books not implement Comparable
* Map позвляет хранить null в качестве ключа, а HashTable нет.
* Map.put(K, V) возвращает предидущее значение или null.
* Collection.sort можно только Comparable or with external Comparator
* Sort с null Comparator'ом сортирует в обычном порядке
* Map->SortedMap->NavigableMap
* FIFO has methods offer(e)/add(e)||peek()/element()||poll()/remove() for this purpose.
* LIFO has methods push(e)||peek()/element()||poll()/remove()/pop() for this purpose.
STREAMS
* UnaryOperator<Long> ex2 = (Long l) -> 3.14 //NOT COMPILE 3.14 is not a Long
* Stream.generate(() -> "A").sorted().limit(2).forEach(System.out::println); //Зависает потому что sorted() работает только с finit streams
* Functional interfaces can't declare checked exceptions
* Streams can be used only one time!
* Stream.sum() is incorrect because IntStream.sum()
* IntStream.average() return optionalDouble
* Stream.iterate(1, x->x++) = 111111111..... инициализирующее значение передается в функцию
* forEach method expects a Consumer as an argument. Not a Function.
JAVA TIME
* static methods like ofXXX() can not be chained
*
*
*
LOCALIZATION 85%
* Java properties class can contain Object values
* Instant do not contains ZoneId(always in GMT)
* Properties.get(String key) Properties.getProperty(String key [String default])
*
*
*
*

EXCEPTIONS & ASSERTIONS 80%
* if exception throwns it must be declared of handled
* assert is the reserved word, you cannot use it as a variable name;
* ParseException, IOException, FileNotFoundException, NotSerializableException, SQLException -- checked
* если поймал IOException e тогда нельза переприсвоить e = new RuntimeException(); потому что это разные типы

CONCURRENCY 50%
* scheduleWithFixedDelay() accepts only Runnable
* если T compute() - тогда класс наследует RecursiveTask
* в reduce() все параметры имеют один тип
* не бывает program hangs & run without issue
* new stream is always not parallel even if all streams in flatMap is parallel
* ()->{return null} incorrect lambda, becouse missing semicolon(;)
* newSingleThreadExecutor() is thread safe ;)
* Нужно быть внимательнее когда блокируется this и static method - это разные объекты
* Concurrent tasks can share the same memory
* Сраный вопро про возможные варианты возврата метода Integer performCount(int number) может вернуть число, null, exception или зависнуть нахуй! Че за пиздец!?

JAVA IO 82%
* PtintWriter.append() not throws IOExceptions & Writer.append() throws IOExceptions
* All instance variables must be serializable OR TRANSIENT
* new File("D:/Java/OCP/Ch06_JavaIOFundamentals/src/main/java/OCP\\AppCopy.java")); при указании пути можно смешивать прямые и обратные слеши
* Console -> format() printf(), readline(), readPassword()
* inputStream.mark() запоминает позицию, markLimit - непонятная хуйня :/

JAVA NIO.2 50%
* Обратить внимание на PATHS VS PATH!!!
* path.relativize() принимает Path а не String
* Path is immutable
* путь Path обрабатывается поочереди вплоть до символических ссылок если /foo ссылка на /bar тогда /foo/1.txt = /bar/1.txt - the same file
* Attention to use BiPredicate in Files.walk().filter() instead of Predicate
* Изучить какие методы Files бросаются checked IOException
* почему-то не проверяют на возможность бросить ексепшены
* Files.resolve(absolutePath) = absolutePath если передана абсолютный путь тогда вернет этот путь!!!
* Files.move()(Rename) всегда копирует атрибуты
* Если сказали что файл существует и доступен для чтения, значит чтение не бросит исключений, если нихера не сказано тогда может бросить исключение
* java.io.File не поддерживает SymbolicLinc!!!
* Path.normalize не преобразовует относительный путь в постоянный ".".normalize() = "."

JDBC 90%
* проверить stmt.absolute() на SCROLL_FORWARD_ONLY работает, но previous() должен бросаться исключениями, хотя не бросается :/
* DriverManager.getConnection() throws SQLException
* Mandatory parts of JDBC URL is jdbc:vendorName:databaseSpecificName(ip & port is optional)